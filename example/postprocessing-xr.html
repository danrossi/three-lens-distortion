<!DOCTYPE html>
<html lang="en">

<head>
    <title>postprocessing - lens distortion effect</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

    <style>
        body {
            touch-action: none;
        }
    </style>
</head>

<body>


    <div id="container"></div>

    <video id="video" loop muted autoplay crossOrigin="anonymous" preload="metadata" playsinline style="display:none">

    </video>

    <script type="importmap">
			{
				"imports": {
					"three": "./three-xr.module.js",
                    "three-lens-distortion": "../build/postprocessing-lens-distortion.module.js",
                    "postprocessing": "./postprocessing.module.js"
				}
			}
		</script>

    <script type="module">

        import {
            HalfFloatType,
            Texture,
            ClampToEdgeWrapping,
            LinearFilter,
            RGBAFormat,
            SphereGeometry,
            PerspectiveCamera,
            Scene,
            MeshBasicMaterial,
            LinearSRGBColorSpace,
            WebGLRenderer,
            Mesh,
            MathUtils,
            Vector2,
            VRButton
        } from 'three';


        import {
            BlendFunction,
            EffectComposer,
            RenderPass,
            EffectPass
        } from "postprocessing";


        import { LensDistortionEffect } from 'three-lens-distortion';


        let _requestVideoFrameCallback = false;


        class CustomVideoTexture extends Texture {

            constructor(video) {
                super(video, Texture.DEFAULT_MAPPING, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearFilter, RGBAFormat);

                this.generateMipmaps = false;

                const updateVideo = () => {

                    this.needsUpdate = true;
                    video.requestVideoFrameCallback(updateVideo);

                }

                if ('requestVideoFrameCallback' in video) {

                    _requestVideoFrameCallback = true;

                    video.requestVideoFrameCallback(updateVideo);

                }

            }

            get isVideoTexture() {
                return true;
            }

            update() {
                if (!_requestVideoFrameCallback) this.needsUpdate = true;
            }

        }


        let camera, scene, renderer, composer;

        let isUserInteracting = false,
            lon = 0, lat = 0,
            phi = 0, theta = 0,
            onPointerDownPointerX = 0,
            onPointerDownPointerY = 0,
            onPointerDownLon = 0,
            onPointerDownLat = 0;

        const distance = 50;

        const video = document.getElementById('video');
        video.src = "//videos.electroteque.org/360/ultra_light_flight_720p.mp4";
        video.play();

        video.addEventListener("loadedmetadata", () => {
            console.log("loadedmetadata");
            init();
        });


        async function init() {

            const container = document.getElementById('container');

            camera = new PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1100);

            scene = new Scene();
            // scene.position.z = - 8;

            const geometry = new SphereGeometry(500, 60, 40);
            // invert the geometry on the x-axis so that all of the faces point inward
            geometry.scale(- 1, 1, 1);


            const texture = new CustomVideoTexture(video);
            texture.colorSpace = LinearSRGBColorSpace;

            const material = new MeshBasicMaterial({ map: texture });

            material.onBeforeCompile = function (shader) {

                shader.fragmentShader = shader.fragmentShader.replace(
                    '#include <map_fragment>',
                    `
					#ifdef USE_MAP
					
						vec4 sampledDiffuseColor = texture2D( map, vMapUv );
					
						// inline sRGB decode
						sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.a );

						diffuseColor *= sampledDiffuseColor;

					#endif

									`
                );

            };



            const mesh = new Mesh(geometry, material);
            scene.add(mesh);

            renderer = new WebGLRenderer();

            renderer.xr.setReferenceSpaceType('local');
            renderer.xr.enabled = true;
            renderer.xr.addEventListener("sessionstart", onSessionStart);
            renderer.xr.addEventListener("sessionend", onSessionEnded);


            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);

            container.appendChild(renderer.domElement);

            document.addEventListener('pointerdown', onPointerDown);
            document.addEventListener('pointermove', onPointerMove);
            document.addEventListener('pointerup', onPointerUp);

            document.body.appendChild(VRButton.createButton(renderer));

            const params = {
                //distortion: new THREE.Vector2(0.5, 0.5),
                distortion: new Vector2(.5, .5),
                principalPoint: new Vector2(0, 0),
                //focalLength: new THREE.Vector2(.5, .5),
                focalLength: new Vector2(1, 1),
                skew: 0
            };

            const effect = new LensDistortionEffect(params);


            composer = new EffectComposer(renderer, {
                frameBufferType: HalfFloatType
            });


            const pass = new EffectPass(camera,
                effect
            );



            //effect.inverted = true;


            composer.addPass(new RenderPass(scene, camera));
            composer.addPass(pass);


            composer.setSize(window.innerWidth, window.innerHeight);



            window.addEventListener('resize', onWindowResize);

            animate();

        }

        function onSessionStart(ev, event) {


            const xrManager = renderer.xr,
                baseReferenceSpace = xrManager.getReferenceSpace(),
                offsetPosition = camera.position,
                offsetRotation = camera.rotation;

            const transform = new XRRigidTransform(offsetPosition, { x: 0, y: -(offsetRotation.y - 0), z: offsetRotation.z, w: offsetRotation.w }),
                teleportSpaceOffset = baseReferenceSpace.getOffsetReferenceSpace(transform);

            xrManager.setReferenceSpace(teleportSpaceOffset);

        }
        function onSessionEnded(ev, event) {




        }



        function onWindowResize() {


            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);


        }

        function onPointerDown(event) {

            isUserInteracting = true;

            onPointerDownPointerX = event.clientX;
            onPointerDownPointerY = event.clientY;

            onPointerDownLon = lon;
            onPointerDownLat = lat;

        }

        function onPointerMove(event) {

            if (isUserInteracting === true) {

                lon = (onPointerDownPointerX - event.clientX) * 0.1 + onPointerDownLon;
                lat = (onPointerDownPointerY - event.clientY) * 0.1 + onPointerDownLat;

            }

        }

        function onPointerUp() {

            isUserInteracting = false;

        }

        let animID;

        function animate() {

            renderer.setAnimationLoop(update);

        }

        function update(deltaTime) {

            lat = Math.max(- 85, Math.min(85, lat));
            phi = MathUtils.degToRad(90 - lat);
            theta = MathUtils.degToRad(lon);

            camera.position.x = distance * Math.sin(phi) * Math.cos(theta);
            camera.position.y = distance * Math.cos(phi);
            camera.position.z = distance * Math.sin(phi) * Math.sin(theta);

            camera.lookAt(0, 0, 0);

            //renderer.render(scene, camera);
            composer.render(deltaTime);


        }

    </script>
</body>

</html>